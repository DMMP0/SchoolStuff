package com.company;

public class Esempio1 extends Algoritmo_Distribuzione_Non_Uniforme
        {

        Generatore_Lineare_Congruenziale glc = new Generatore_Lineare_Congruenziale(true);

//costruttore
public Esempio1()
        {
        Max = 1000;
        Nome = "y = e^-x";
        PrimitivaScelta = "y = 1 - e^-x";
        FunzioneInversa = "F^-1(x) = -ln(1-x)";
        FunzioneFinale = " x = -ln(1-r)";

        }

//metodi ci cui fare l' override
            @Override
public String Descrizione()
        {
        return "Questo è un esempio di algoritmo di distribuzione non uniforme.\n"+
        "La funzione iniziale è "+Nome+";\n"+
        "La primitiva scelta è "+PrimitivaScelta+";\n"+
        "La funzione inversa della primitiva scelta è "+FunzioneInversa+";\n"+
        "La funzione finale esplicitata in x è quindi "+FunzioneFinale+";\n"+
        "Prendendo come input un numero doublee generato dal GLC,\nper restituire il numero finale si prendono in considerazione le cifre meno significative" ;
        }
        @Override
public  String Description()
        {
        return "This is an example of a non-uniform distributed algorithm .\n"+
        "The initial function is "+Nome+";\n"+
        "The primitive is "+PrimitivaScelta+";\n"+
        "The inverted function of the primitive is "+FunzioneInversa+";\n"+
        "The final function explicated in x is "+FunzioneFinale+";\n"+
        "Taking as input a double number generated by GLC,\nthe less significant digits are taken into consideration to get the final number" ;
        }
        @Override
public  String 叙述()
        {
        return "これは偏在の擬似乱数生成器の例\n"+
        "初めの式は "+Nome+";\n"+
        "インテグラルは "+PrimitivaScelta+";\n"+
        "インテグラルのf,xの逆関数は"+FunzioneInversa+";\n"+
        "終わりのxの式は "+FunzioneFinale+";\n"+
        "インプットは合目的的線状擬似乱数生成器の十進数アウトプットです。\n終わりのアウトプットは十進数アウトプットの最下位値" ;

        }

//altri metodi
                @Override
protected  double GeneraDecimal()
        {


        double r = glc.Genera(0, 1, true);
        return -1* Math.log((1 - r));
        }
        @Override
public  int Genera()
        {
        int ris;
        do{
        ris =  ((int)Math.round(((GeneraDecimal()*100000000000000d)%10000d)))%Max;
        }while(ris < Min);
        return ris;
        }
        } //all ok
